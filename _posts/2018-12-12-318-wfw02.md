---
layout: post
title: 【杏仁技术站】乐高式微服务化改造（下） 
pid: 318
tags: [microservice]
---

上篇讲了杏仁微服务化改造的项目背景和基本框架，这篇我将进一步介绍其中的三大核心组件，即注册中心，配置中心和授权中心。

1. 注册中心：所有服务注册到 Consul 集群，然后通过 Consul Template 刷新Nginx配置实现负载均衡
2. 配置中心：使用自研的 Matrix 系统，通过自定义构建插件覆写配置，最小化对已有应用的侵入性
3. 授权中心：基于 Spring Security OAuth，同时支持基于微信企业号的 SSO

# 注册中心

作为微服务架构最基础也是最重要的组件之一，*服务注册中心本质上是为了解耦服务提供者和服务消费者*。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态 LB 机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。


设计或者选型一个服务注册中心，首先要考虑的就是服务注册与发现机制。纵观当下各种主流的服务注册中心解决方案，大致可归为三类：


- 应用内：直接集成到应用中，依赖于应用自身完成服务的注册与发现，最典型的是 Netflix 提供的 Eureka
- 应用外：把应用当成黑盒，通过应用外的某种机制将服务注册到注册中心，最小化对应用的侵入性，比如 Airbnb 的 SmartStack，HashiCorp 的 Consul
- DNS：将服务注册为 DNS 的 SRV 记录，严格来说，是一种特殊的应用外注册方式，SkyDNS 是其中的代表


注1：对于第一类注册方式，除了 Eureka 这种一站式解决方案，还可以基于 ZooKeeper 或者 Etcd 自行实现一套服务注册机制，这在大公司比较常见，但对于小公司而言显然性价比太低。

注2：由于 DNS 固有的缓存缺陷，这里不对第三类注册方式作深入探讨。


除了基本的服务注册与发现机制，从开发和运维角度，至少还要考虑如下五个方面：

- 测活：服务注册之后，如何对服务进行测活以保证服务的可用性？
- 负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？
- 集成：在服务提供端或者调用端，如何集成注册中心？
- 运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？
- 可用性：如何保证注册中心本身的可用性，特别是消除单点故障？

框架选型


下面就围绕这几个方面，简单分析一下 Eureka，SmartStack，Consul 的利弊。

*Eureka*

![](/uploads/2018/12/12-09.jpg)

从设计角度来看，Eureka 可以说是无懈可击，注册中心、提供者、调用者边界清晰，通过去中心化的集群支持保证了注册中心的整体可用性，但缺点是 Eureka 属于应用内的注册方式，对应用的侵入性太强，且只支持 Java 应用。


*SmartStack*

![](/uploads/2018/12/12-10.jpg)

SmartStack 可以说是三种方案中最复杂的，涉及了 ZooKeeper、HAProxy、Nerve 和 Synapse 四种异构组件，对运维提出了很高的要求。它最大的好处是对应用零侵入，且适用于任意类型的应用。

*Consul*



Consul 本质上属于应用外的注册方式，但可以通过集成 Consul SDK 加上本地 Agent的 方式简化注册流程。当服务以容器方式运行时，可以更进一步通过Registrator 实现自动注册。服务调用端的服务发现默认依赖于 SDK，但可以通过 Consul Template 去除 SDK 依赖。

*最终方案*

最终我们选择了 Consul 作为服务注册中心的实现方案，主要原因有两点：

1. 最小化对已有应用的侵入性，这也是贯穿我们整个微服务化改造的原则之一。
2. 降低运维的复杂度，通过使用 Registrator 和 Consul Template 实现服务自注册和自发现。

![](/uploads/2018/12/12-11.jpg)

# 配置中心

我们知道，大至一个 PaaS 平台，小至一个缓存框架，一般都依赖于特定的配置以正常提供服务，微服务也不例外。


配置中心按不同的类型划分，有不同的类型。

- 按配置的来源划分，主要有源代码（俗称 hard-code），文件，数据库和远程调用。
- 按配置的适用环境划分，可分为开发环境，测试环境，预发布环境，生产环境等。
- 按配置的集成阶段划分，可分为编译时，打包时和运行时。编译时，最常见的有两种，一是源代码级的配置，二是把配置文件和源代码一起提交到代码仓库中。打包时，即在应用打包阶段通过某种方式将配置（一般是文件形式）打入最终的应用包中。运行时，是指应用启动前并不知道具体的配置，而是在启动时，先从本地或者远程获取配置，然后再正常启动。
- 按配置的加载方式划分，可分为单次加载型配置和动态加载型配置。

随着业务复杂度的上升和技术架构的演变，对应用的配置方式也提出了越来越高的要求。一个典型的演变过程往往是这样的，起初所有配置跟源代码一起放在代码仓库中；之后出于安全性的考虑，将配置文件从代码仓库中分离出来，或者放在 CI 服务器上通过打包脚本打入应用包中，或者直接放到运行应用的服务器的特定目录下，剩下的非文件形式的关键配置则存入数据库中。上述这种方式，在单体应用阶段非常常见，也往往可以运行的很好，但到了微服务阶段，面对爆发式增长的应用数量和服务器数量，就显得无能为力了。这时，就轮到配置中心大显身手了。那什么是配置中心？简单来说，就是一种统一管理各种应用配置的基础服务组件。


*框架选型*

选型一个合格的配置中心，至少需要满足如下 4 个核心需求：

- 非开发环境下应用配置的保密性，避免将关键配置写入源代码
- 不同部署环境下应用配置的隔离性，比如非生产环境的配置不能用于生产环境
- 同一部署环境下的服务器应用配置的一致性，即所有服务器使用同一份配置
- 分布式环境下应用配置的可管理性，即提供远程管理配置的能力

现在开源社区主流的配置中心框架有 Spring Cloud Config 和 Disconf，两者都满足了上述4个核心需求，但又有所区别。

*Spring Cloud Config*

![](/uploads/2018/12/12-12.jpg)

Spring Cloud Config 可以说是一个为 Spring 量身定做的轻量级配置中心，巧妙的将应用运行环境映射为 profile，应用版本映射为 label。在服务端，基于特定的外部系统（Git、文件系统或者 Vault）存储和管理应用配置；在客户端，利用强大的 Spring 配置系统，在运行时加载应用配置。

*Disconf*

![](/uploads/2018/12/12-13.jpg)

disconf是前百度资深研发工程师廖绮绮的开源作品。在服务端，提供了完善的操作界面管理各种运行环境，应用和配置文件；在客户端，深度集成Spring，通过Spring AOP实现应用配置的自动加载和刷新。

*最终方案*

不管是 Spring Cloud Config 还是 disconf，默认提供的客户端都深度绑定了 Spring 框架，这对非 Spring 应用而言无疑增加了集成成本，即便它们都提供了获取应用配置的 API。


最终我们还是选用了微服务化改造之前自研的 Matrix 作为配置中心，一方面，可以保持新老系统使用同一套配置服务，降低维护成本，另一方面，在满足 4 个核心需求的前提下，Matrix 还提供了一些独有的能力。

- 分离配置文件和配置项。对于配置文件，通过各类配套打包插件（sbt，maven，gradle），在打包时将配置文件打入应用包中，同时最小化对CI的侵入性；对于配置项，提供 SDK，帮助应用从服务端获取配置项，同时支持简单的缓存机制。
- 增加应用版本维度，即对于同一应用，可以在服务端针对不同版本或版本区间维护不同的应用配置。
- 应用配置的版本化支持，类似于 Git，可以将任一应用配置回退到任一历史版本。

# 授权中心


有了服务注册中心和配置中心，下一步应该就可以发起服务调用了吧？Wait，还有一个关键问题要解决。不同于单体应用内部的方法调用，服务调用存在一个服务授权的概念。打个比方，原本一家三兄弟住一屋，每次上山打猎喊一声就行，后来三兄弟分了家，再打猎就要挨家挨户敲门了。这一敲一应就是所谓的服务授权。


严格来说，服务授权包含鉴权（Authentication）和授权（Authorization）两部分。*鉴权解决的是调用方身份识别的问题*，即敲门的是谁。*授权解决的是调用是否被允许的问题*，即让不让进门。两者一先一后，缺一不可。为避免歧义，如不特殊指明，下文所述授权都是宽泛意义上的授权，即包含了鉴权。


常见的服务授权有三种，简单授权，协议授权和中央授权。

- 简单授权：服务提供方并不进行真正的授权，而是依赖于外部环境进行自动授权，比如IP地址白名单，内网域名等。这就好比三兄弟互相留了一个后门。
- 协议授权：服务提供方和服务调用方事先约定一个密钥，服务调用方每次发起服务调用请求时，用约定的密钥对请求内容进行加密生成鉴权头（包含调用方唯一识别 ID），服务提供方收到请求后，根据鉴权头找到相应的密钥对请求进行鉴权，鉴权通过后再决定是否授权此次调用。这就好比三兄弟之间约定敲一声是大哥，敲两声是二哥，敲三声是三弟。
- 中央授权：引入独立的授权中心，服务调用方每次发起服务调用请求时，先从授权中心获取一个授权码，然后附在原始请求上一起发给服务提供方，提供方收到请求后，先通过授权中心将授权码还原成调用方身份信息和相应的权限列表，然后决定是否授权此次调用。这就好比三兄弟每家家门口安装了一个110联网的指纹识别器，通过远程指纹识别敲门人的身份。


一般来说，简单授权在业务规则简单、安全性要求不高的场景下用的比较多。而协议授权，比较适用于点对点或者 C/S 架构的服务调用场景，比如 Amazon S3 API。对于网状结构的微服务而言，中央授权是三种方式中最适合也是最灵活的选择：

- 简化了服务提供方的实现，让提供方专注于权限设计而非实现。
- 更重要的是提供了一套独立于服务提供方和服务调用方的授权机制，无需重新发布服务，只要在授权中心修改服务授权规则，就可以影响后续的服务调用。

*Oauth*


说起具体的授权协议，很多人第一反应就是OAuth。事实上也的确如此，很多互联网公司的开放平台都是基于 OAuth 协议实现的，比如 Google APIs，微信网页授权接口。一次标准的 OAuth 授权过程如下：

![](/uploads/2018/12/12-14.jpg)

对应到微服务场景，服务提供方相当于上图中的 Resource Server，服务调用方相当于 Client，而授权中心相当于 Authorization Server 和 Resource Owner 的合体。

*Beared Token*

在标准的 OAuth 授权过程中，Resource Server 收到 Client 发来的请求后，需要到 Authorization Server 验证 Access Token，并获取 Client 的进一步信息。通过 OAuth 2.0 版本引入中的 Beared Token，我们可以省去这一次调用，将 Client 信息存入 Access Token，并在 Resource Server 端完成 Access Token 的鉴权。主流的 Beared Token 有 SAML 和 JWT 两种格式，SAML 基于 XML，而 JWT 基于 JSON。由于大多数微服务都使用 JSON 作为序列化格式，JWT 使用的更为广泛。

*框架选型*

在选型OAuth框架时，我主要调研了 CAS，Apache Oltu，Spring Security OAuth 和 OAuth-Apis，对比如下：

![](/uploads/2018/12/12-15.jpg)

不考虑实际业务场景，CAS 和 Spring Security OAuth 相对另外两种框架，无论是集成成本还是可扩展性，都有明显优势。前文提到，由于我们选用了 Spring Boot 作为统一的微服务实现框架，Spring Security OAuth 是更自然的选择，并且维护成本相对低一些（服务端）。

*最终方案*

最后我们基于 Spring Security OAuth 框架实现了自己的服务授权中心，鉴权部分目前支持私网认证，Scope 校验和域名校验。大致的服务授权流程如下：

![](/uploads/2018/12/12-16.jpg)

# 更多

微服务是一个很大的话题，自 Martin Fowler 在 2014 年 3 月提出以来，愈演愈热，并跟另一个话题容器化一起开创了一个全新的 DevOps 时代，引领了国内外大大小小各个互联网公司的技术走向，也影响了我们这一代程序员尤其是后端和运维的思维方式。希望我的这两篇文章能给你带来一些新的启发和思考，欢迎留言交流。

> 少年读书如隙中窥月，中年读书如庭中望月，老年读书如台上玩月，皆以阅历之浅深为所得之浅深耳。-- 张潮 《幽梦影》
	
# 参考

[乐高式微服务化改造（下）](https://mp.weixin.qq.com/s/MYNChqtCdZyaUqw89AkuAw)